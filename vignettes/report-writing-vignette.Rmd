---
title: "Report Writing"
output: 
  rmarkdown::html_vignette:
vignette: >
  %\VignetteIndexEntry{report-writing-vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.retina = 3,
  fig.width = 6,
  fig.asp = 0.618, 
  fig.align = "center",
  out.width = "90%"
)
```

```{r setup, include = FALSE}
library(ratlas)
library(here)
library(tidyverse)
library(kableExtra)
library(english)
library(knitr)
```

## Creating a New Project

When beginning a new report, the first step is to create a new project
in RStudio. This can be done by clicking: 
  
<center> **File > New Project > New Directory > New Project** </center>

From there, specify the project name and the directory where you would like to 
save the project for the new report. To lessen confusion later, it is usually 
worthwhile to save each report in its own directory/project so that you can 
quickly and easily find the report at a later date.

## Structuring the Project Directories

Once the project has been created, the next step is to create the file structure 
for the report. To do this, begin by making sure the here package is installed. 
If it is not installed, type `install.packages("here)`. After here is installed, 
type `library(here)` to load the library into RStudio. 

The `here()` function is designed to reference the directory where you have 
saved your project file, which is why the project file should always be 
created first. 

After the here package has been installed and loaded, four project directories 
will need to be created. These four directories are:

- R/
- data-raw/
- data/
- output/

To create the R directory, type the command `dir.create(here("R"))`. This will 
create the folder, and you should be able to see it in your file directory at 
the lower right corner of your RStudio screen. The same process can be used to 
create the remaining three directories with the following code: 

- `dir.create(here("data-raw"))`
- `dir.create(here("data"))`
- `dir.create(here("output"))`

The R directory is used to store analysis scripts.

The data-raw directory is used to store raw data files.

The data directory is used to store cleaned or intermediate files.

The output directory is used to store final output files that can be read into 
the report.

## Creating the R Markdown File

Now that the project and the file directories have been created, it is time to 
create the R Markdown file, which is where the report will be written. An 
R Markdown file can be created by clicking:

<center> **File > New File > R Markdown...** </center>

In setting up the new R Markdown file, you will be able to set a few of the 
default settings. Under the document table, the author and title can be 
specified. These entries will be added to report text, so it is important to 
distinguish between the title and the eventual file name that will be given to 
the R Markdown file when saving. Also, the type of output can be specified when 
creating the R Markdown file. The three predominant output types are html, word 
documents, and pdf documents. 

## Writing the Setup Chunk

The Setup Chunk is where you set all of the default settings for your report. 
In doing this, you want to create the Setup Chunk so that all of the necessary 
settings can be set in a reproducible way. In other words, you want the code to 
be able to run on any computer, not just yours.

In the default template for R Markdown files, the Setup Chunk is the first code 
chunk that looks like:

```{r setup_chunk_example, eval = FALSE, echo = TRUE}
knitr::opts_chunk$set(echo = TRUE)
```

The first step in doing this is to load the needed packages. Bear in mind that 
not all computers will have the the necessary packages installed already. Thus, 
the code in the Setup Chunk needs to test whether these are already installed, 
install them if they are not already installed, and then load the packages. 

This can be done by running the following code:

```{r package_install_loading, echo = TRUE, eval = FALSE}
needed_packages <- c("ratlas", "tidyverse", "english", "kableExtra")
load_packages <- function(x) {
  if (!(x %in% installed.packages())) {
    install.packages(x)
  }
  suppressPackageStartupMessages(require(x, character.only = TRUE))
}
vapply(needed_packages, load_packages, logical(1))

system <- ifelse(Sys.info()["sysname"] == "Darwin", "Mac", "Windows")

extrafont::loadfonts(quiet = TRUE)
```

Additionally, the theme for ggplot should be specified. This can be done with 
the either of the following code chunks.

```{r set_ggplot_theme1, echo = TRUE, eval = FALSE}
theme_atlas()
```

Or

```{r set_ggplot_theme2, echo = TRUE, eval = FALSE}
theme_atlas_ms()
```

Together, your first chunk of the file should look like:

```{r setup_chunk, echo = TRUE, eval = FALSE}
needed_packages <- c("ratlas", "tidyverse", "english", "kableExtra")
load_packages <- function(x) {
  if (!(x %in% installed.packages())) {
    install.packages(x)
  }
  suppressPackageStartupMessages(require(x, character.only = TRUE))
}
vapply(needed_packages, load_packages, logical(1))

system <- ifelse(Sys.info()["sysname"] == "Darwin", "Mac", "Windows")

extrafont::loadfonts(quiet = TRUE)

theme_atlas()
#OR
#theme_atlas_ms()
```

For simplicity, this setup code chunk can just be copy and pasted into the 
rmarkdown file to write the report. Please note, however, that you should only
select one of the two ATLAS themes (theme_atlas and theme_atlas_ms). 
`Theme_atlas_ms()` has been commented out in the above code, but `theme_atlas()`
be commented out if `theme_atlas_ms()` is desired.

## Create and Cross Reference Tables

Tables can be created using the kable function in the kableExtra package in R. 

Creating tables is relatively simple. The kable package takes an existing 
dataset and places the vectors (i.e., columns in the data frame) into columns in
the table. 

As an example, take the *iris* dataset that is automatically loaded in R. To 
make a more reasonably sized table for this example, let's filter the dataset to
flowers with petal length greater than 6.0 with the following code:

```{r filtered_iris, echo = TRUE, eval = TRUE}
temp <- iris %>%
  filter(Petal.Length > 6.0) %>%
  arrange(desc(Petal.Length))

temp
```

Do note, that this example uses the tidyverse package in filtering the data.

Now that the data is more manageable, the smaller dataset can be turned into a 
table. The full kable function help page can be found by using the `?kable` 
command. The full details for the kable function parameters can be found here. 

Briefly, *x* holds the data frame, *digits* indicates the number of digits 
displayed to the right of the decimal point, *col.names* indicates what each 
column should be named, *align* specifies how to align the data within each 
column, *caption* specifies the title for the table, *booktabs* specifies 
formatting for the table (i.e., the bolded column headers, the horizontal lines,
the subtle horizontal lines between each row), and *format.args* specifies 
format arguments to be used in the table. In this instance, *big.mark = ","* 
specifies that commas should be inserted to the left of the decimal point when 
necessary to improve readability (i.e., printing 3,400 instead of 3400).

```{r iris, echo = TRUE}
kable(x = temp, digits = 1, col.names = c("Sepal Length", "Sepal Width", 
                                          "Petal Length", "Petal Width", 
                                          "Species"), 
      align = "c", caption = "A table of irises with long petals", 
      booktabs = TRUE, format.args = list(big.mark = ","))
```

Tables may be referenced using the following inline command: 
`\@ref(tab:chunk-label)`. Please note, however, that the text to the right of 
the colon refers to the code chunk name. Of special importance, cross-references
cannot use an underscore in the name of the code chunk. The underscore is a 
special character in Latex, which causes difficulties in referencing table code 
chunks using an underscore in the name.

Although not shown above, the code chunk containing the table was labeled *iris*.
In completing this example, we can then reference the numbered table using 
`\@ref(tab:iris)`, and a hyperlink will appear with the number of the table. The 
hyperlink can be clicked to direct the user to the location of the table in the 
document.

## Create and Cross Reference Figures

Figures are created using the ggplot2 package which is a part of the tidyverse 
family of packages. Figures are created using multiple steps and layers. The 
first step is to import the data into ggplot. This can be done using the 
following code:

```{r first_layer, echo = TRUE, eval = FALSE}
iris %>%
  ggplot()
```

The next step is to add layers to the graph. The first layer specifies the 
aesthetics. Within the ggplot function, the parameter *aes* corresponds to the 
aesthetics that are specified. For this graph, let's create a scatterplot with 
petal length on the x-axis, petal width on the y-axis, and the color of each 
point will correspond with species. The aesthetics of such a graph are specified
in the following code:

```{r second_layer, echo = TRUE, eval = FALSE}
iris %>%
  ggplot(aes(x = Petal.Length, y = Petal.Width, color = Species))
```

While the above code specifies how to map the graph aesthetics, no points are 
plotted on the coordinate plane. This is because the second layer involved in 
creating a figure is to add a geometric object layer that corresponds to the 
type of graph that is desired. In this case, we will use `geom_point` since we 
want to create a scatterplot. The geometric object layers are added using a *+* 
sign from the line above. The code below provides an example of adding the 
`geom_point` geometric object layer.

```{r third_layer, echo = TRUE}
iris %>%
  ggplot(aes(x = Petal.Length, y = Petal.Width, color = Species)) +
  geom_point()
```

In the graph above, you will notice that there are no parameters for the 
`geom_point` layer. This is done for two reasons. First, all of the global 
parameters specified in the `ggplot(aes(...))` layer are passed on to subsequent
layers. Thus, `geom_point` is run using the global parameters. Second, there 
were no necessary local changes, and hence no new parameters were necessary.

Geometric objects can also be layered on one another. The graph below adds a 
regression line using a `geom_smooth` object:

```{r fourth_layer, echo = TRUE}
iris %>%
  ggplot(aes(x = Petal.Length, y = Petal.Width, color = Species)) +
  geom_point() + 
  geom_smooth(method = "lm", se = FALSE)
```

Note, however, that adding the `geom_smooth` object actually provided three 
regression lines, one for each species of iris. This is because the global 
settings  are specified to color each species differently. In order to create a 
single regression line, the color aesthetic must be specified locally for the 
`geom_point` object. This will allow the points to be colored according to 
species, while drawing a single regression line through the points. Furthermore, 
the default color of the regression line will be overridden with 
`color = "black"` in the `geom_smooth` geometric object.

```{r iris-figure, echo = TRUE}
iris %>%
  ggplot(aes(x = Petal.Length, y = Petal.Width)) +
  geom_point(aes(color = Species)) + 
  geom_smooth(method = "lm", se = FALSE, color = "black")
```

Cross-referencing figures can be done similarly to cross-referencing tables. The
most notable difference is the syntax for referencing a figure. To reference a 
figure, we can use `\@ref(fig:chunk-label)`. Once again, *chunk-label* refers to
the name of the code chunk containing the figure. In this case, the code chunk 
name is *iris-figure*. Therefore, we can use `\@ref(fig:iris-figure)` to 
reference the figure.

## Using Inline R Code 

Up to this point, all of the code that has been discussed has involved code 
chunks. Code can also be evalued inline so that the results are presented in the
sentence without special formatting. By using `` `r
r_code` ``, the results of *r_code* would be pasted into the text. Consider the 
following example. If I am describing the iris dataset, I might want to state 
the mean petal length in the text. To do this using inline code, I might say:

The mean petal length of the irises was `r mean(iris$Petal.Length)`, which uses
`` `r
mean(iris$Petal.Length)` `` as the inline coded. 

## Combining Words

When using inline code, it is sometimes possible to generate character strings 
(i.e., words) that would be listed in a grammatically incorrect way. For 
example, an inline code might return "apples" "oranges" "bananas", which should 
grammatically be listed as "apples, oranges, and bananas." 

The `combine_words` function in the knitr package does just that. By placing the
inline code as a parameter within the `knitr::combinewords()` function, the 
`combine_words` function will combine the items into a list with commas and an 
"and" when necessary. Alternatively, `combine_words` will place an "and" between
words when there are only two words returned by the inline function, and 
`combine_words` will not alter the inline function's returned value when the 
returned value is only a single character string. 

To demonstrate, I will use the command `colnames(iris)` to return all of the 
column header names for the iris dataset, which consists of five different 
character strings. When wrapping the `colnames(iris)` command in the 
`knitr::combine_words()` function, the inline text becomes `r knitr::combine_words(colnames(iris))` 
via `` `r
knitr::combine_words(colnames(iris))` ``.

For additional help regarding the `combine_words` function, you can visit the 
`?combine_words` help page.

## Turning Numbers Into Words

Often times, computer code will generate numerical answers when an answer 
written in words is more appropriate whether by convention, publishing 
standards, etc. The english package allows for numbers to be converted to a 
variety of written formats. 

First, it should be noted that the english package supports converting numbers 
only into the English language. Furthermore, the english package allows the user
to specify whether to use American style English or UK style English. This can 
be set with either `options(english.UK = TRUE)` or 
`options(english.UK = FALSE)`. For the purposes of this vignette, the option 
will be set to American style English.

```{r english_settings, include = FALSE}
options(english.UK = FALSE)
```

Within the english package, there are four primary functions. The first function
is `words` or `Words`. These two functions have the same functionality, although
`Words` capitalizes the first letter of the word, whereas `word` leaves all of 
the letters lowercase. The second function is the `ordinal` function, which 
converts the numbers to ordinal numbers (e.g., 5 becomes fifth). The third 
function is `indefinite` or `Indefinite`. Like the `words` and `Words` function,
the only difference between these two indefinite functions is the 
capitalization. The indefinite functions put an indefinite article (i.e., "a" or
"an") before each word (e.g., 8 becomes "an eight"). Importantly, the indefinite
functions allow for the indefinite article to be added without changing the word
to a number. This can be done with `indefinite(8, words = FALSE)`. The fourth 
and final function is the `as.roman` function, which is technically a part of 
the utils package, which means it should be called using `utils::as.roman`. The 
`as.roman` function converts numbers to their Roman numeral equivalent (e.g., 3 
becomes III).

Examples of each of the four functions are provided below.

The `words` function can convert 3 to `r words(3)` via `` `r
words(3)` ``. Although grammatically incorrect, the `Words` function can convert
3 to `r Words(3)` via `` `r
Words(3)` ``.

The `ordinal` function can convert 3 to `r ordinal(3)` via `` `r
ordinal(3)` ``.

The `indefinite` function can convert 3 to `r indefinite(3)` via `` `r
indefinite(3)` ``. Once again, it is grammatically incorrect, but the 
`Indefinite` function can convert 3 to `r Indefinite(3)` via `` `r
Indefinite(3)` ``. To demonstrate the ability to add the indefinite article 
without converting the number to a word, the `indefinite` function can convert 
3 to `r indefinite(3, words = FALSE)` via `` `r
indefinite(3, words = FALSE)` ``.

The `as.roman` function can convert 3 to `r utils::as.roman(3)` via `` `r
utils::as.roman(3)` ``.
