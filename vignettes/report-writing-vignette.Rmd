---
title: "Report Writing"
output: 
  rmarkdown::html_vignette:
vignette: >
  %\VignetteIndexEntry{report-writing-vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "figure/",
  fig.retina = 3,
  fig.width = 6,
  fig.asp = 0.618, 
  fig.align = "center",
  out.width = "90%"
)
```

```{r setup, include = FALSE}
library(ratlas)
library(here)
library(tidyverse)
library(kableExtra)
library(english)
library(knitr)
```

## Creating a New Project

When beginning a new report, the first step is to create a new project
in RStudio. This can be done by clicking: 
  
<center> **File > New Project > New Directory > New Project** </center>

From there, specify the project name and the directory where you would like to 
save the project for the new report. To lessen confusion later, it is usually 
worthwhile to save each report in its own directory so that you can quickly and 
easily find the report at a later date.

## Structuring the Project Directories

Once the project has been created, the next step is to create the file structure 
for the report. To do this, begin by typing `library(here)` into the RStudio 
Console. Note, you will need to install the here package if it is not already 
installed. The here package can be installed by typing `install.packages("here)`.

![Type RStudio Console Commands](figure/type-commands-console.png)



After the here package has been installed and loaded, four project directories 
will need to be created. These four directories are:

- R/
- data-raw/
- data/
- output/

To create the R directory, type the command `dir.create(here("R"))`. This will 
create the folder, and you should be able to see it in your file directory at 
the lower right corner of your RStudio screen. The same process can be used to 
create the remaining three directories. 

The R directory is used to store analysis scripts.

The data-raw directory is used to store raw data files.

The data directory is used to store cleaned or intermediate files.

The output directory is used to store final output files that can be read into 
the report.

## Writing the Setup Chunk

The Setup Chunk is where you set all of the default settings for your report. 
In doing this, you want to create the Setup Chunk so that all of the necessary 
settings can be set in a reproducible way. In other words, you want the code to 
be able to run on any computer, not just yours.

The first step in doing this is to load the needed packages. Bear in mind that 
not all computers will have the the necessary packages installed already. Thus, 
the code in the Setup Chunk needs to test whether these are already installed, 
install them if they are not already installed, and then load the packages. 

This can be done by running the following code:

```{r package_install_loading, echo = TRUE, eval = FALSE}
needed_packages <- c("ratlas", "tidyverse", "english", "kableExtra")
load_packages <- function(x) {
  if (!(x %in% installed.packages())) {
    install.packages(x)
  }
  suppressPackageStartupMessages(require(x, character.only = TRUE))
}
vapply(needed_packages, load_packages, logical(1))

system <- ifelse(Sys.info()["sysname"] == "Darwin", "Mac", "Windows")

extrafont::loadfonts(quiet = TRUE)
```

Additionally, the theme for ggplot should be specified. This can be done with 
the following code.

```{r set_ggplot_theme, echo = TRUE, eval = FALSE}

```

Together, your first chunk of the file should look like:

```{r setup_chunk, echo = TRUE, eval = FALSE}
needed_packages <- c("ratlas", "tidyverse", "english", "kableExtra")
load_packages <- function(x) {
  if (!(x %in% installed.packages())) {
    install.packages(x)
  }
  suppressPackageStartupMessages(require(x, character.only = TRUE))
}
vapply(needed_packages, load_packages, logical(1))

system <- ifelse(Sys.info()["sysname"] == "Darwin", "Mac", "Windows")

extrafont::loadfonts(quiet = TRUE)

```

For simplicity, this setup code chunk can just be copy and pasted into the 
rmarkdown file to write the report. 

## Create and Cross Reference Tables

Tables can be created using the kable function in the kableExtra package in R. 

Creating tables is relatively simple. The kable package takes an existing 
dataset and places the vectors (i.e., columns in the data frame) into columns in
the table. 

As an example, take the *iris* dataset that is automatically loaded in R. To 
make a more reasonably sized table for this example, let's filter the dataset to
flowers with petal length greater than 6.0 with the following code:

```{r filtered_iris, echo = TRUE, eval = TRUE}
temp <- iris %>%
  filter(Petal.Length > 6.0) %>%
  arrange(desc(Petal.Length))

temp
```

Do note, that this example uses the tidyverse package in filtering the data.

Now that the data is more manageable, the smaller dataset can be turned into a 
table. The full kable function help page can be found by using the `?kable` 
command. The full details for the kable function parameters can be found here. 

Briefly, *x* holds the data frame, *digits* indicates the number of digits 
displayed to the right of the decimal point, *col.names* indicates what each 
column should be named, *align* specifies how to align the data within each 
column, *caption* specifies the title for the table, *booktabs* specifies 
formatting for the table (i.e., the bolded column headers, the horizontal lines,
the subtle horizontal lines between each row), and *format.args* specifies 
format arguments to be used in the table. In this instance, *big.mark = ","* 
specifies that commas should be inserted to the left of the decimal point when 
necessary to improve readability (i.e., printing 3,400 instead of 3400).

```{r iris, echo = TRUE}
kable(x = temp, digits = 1, col.names = c("Sepal Length", "Sepal Width", 
                                          "Petal Length", "Petal Width", 
                                          "Species"), 
      align = "c", caption = "A table of irises with long petals", 
      booktabs = TRUE, format.args = list(big.mark = ","))
```

Tables may be referenced using the following inline command: 
`\@ref(tab:chunk-label)`. Please note, however, that the text to the right of 
the colon refers to the code chunk name. Of special importance, cross-references
cannot use an underscore in the name of the code chunk. The underscore is a 
special character in Latex, which causes difficulties in referencing table code 
chunks using an underscore in the name.

In completing this example, we can then reference the numbered table using 
`\@ref(tab:iris)`, and a hyperlink will appear with the number of the table. The 
hyperlink can be clicked to direct the user to the location of the table in the 
document.

## Create and Cross Reference Figures

Figures are created using the ggplot2 package which is a part of the tidyverse 
family of packages. Figures are created using multiple steps and layers. The 
first step is to import the data into ggplot. This can be done using the 
following code:

```{r first_layer, echo = TRUE, eval = FALSE}
iris %>%
  ggplot()
```

The next step is to add layers to the graph. The first layer specifies the 
aesthetics. Within the ggplot function, the parameter *aes* corresponds to the 
aesthetics that are specified. For this graph, let's create a scatterplot with 
petal length on the x-axis, petal width on the y-axis, and the color of each 
point will correspond with species. The aesthetics of such a graph are specified
in the following code:

```{r second_layer, echo = TRUE, eval = FALSE}
iris %>%
  ggplot(aes(x = Petal.Length, y = Petal.Width, color = Species))
```

While the above code specifies how to map the graph aesthetics, no points are 
plotted on the coordinate plane. This is because the second layer involved in 
creating a figure is to add a geometric object layer that corresponds to the 
type of graph that is desired. In this case, we will use `geom_point` since we 
want to create a scatterplot. The geometric object layers are added using a *+* 
sign from the line above. The code below provides an example of adding the 
`geom_point` geometric object layer.

```{r third_layer, echo = TRUE}
iris %>%
  ggplot(aes(x = Petal.Length, y = Petal.Width, color = Species)) +
  geom_point()
```

In the graph above, you will notice that there are no parameters for the 
`geom_point` layer. This is done for two reasons. First, all of the global 
parameters specified in the `ggplot(aes(...))` layer are passed on to subsequent
layers. Thus, `geom_point` is run using the global parameters. Second, there 
were no necessary local changes, and hence no new parameters were necessary.

Geometric objects can also be layered on one another. The graph below adds a 
regression line using a `geom_smooth` object:

```{r fourth_layer, echo = TRUE}
iris %>%
  ggplot(aes(x = Petal.Length, y = Petal.Width, color = Species)) +
  geom_point() + 
  geom_smooth(method = "lm", se = FALSE)
```

Note, however, that adding the `geom_smooth` object actually provided three 
regression lines, one for each species of iris. This is because the global 
settings  are specified to color each species differently. In order to create a 
single regression line, the color aesthetic must be specified locally for the 
`geom_point` object. This will allow the points to be colored according to 
species, while drawing a single regression line through the points. Furthermore, 
the default color of the regression line will be overridden with 
`color = "black"` in the `geom_smooth` geometric object.

```{r iris-figure, echo = TRUE}
iris %>%
  ggplot(aes(x = Petal.Length, y = Petal.Width)) +
  geom_point(aes(color = Species)) + 
  geom_smooth(method = "lm", se = FALSE, color = "black")
```

Cross-referencing figures can be done similarly to cross-referencing tables. The
most notable difference is the syntax for referencing a figure. To reference a 
figure, we can use `\@ref(fig:chunk-label)`. Once again, *chunk-label* refers to
the name of the code chunk containing the figure. In this case, the code chunk 
name is *iris-figure*. Therefore, we can use `\@ref(fig:iris-figure)` to 
reference the figure.

## Using Inline R Code 

Up to this point, all of the code that has been discussed has involved code 
chunks. Code can also be evalued inline so that the results are presented in the
sentence without special formatting. By using `` `r
r_code` ``, the results of *r_code* would be pasted into the text. Consider the 
following example. If I am describing the iris dataset, I might want to state 
the mean petal length in the text. To do this using inline code, I might say:

The mean petal length of the irises was `r mean(iris$Petal.Length)`, which uses
`` `r
mean(iris$Petal.Length)` `` as the inline coded. 

## Combining Words

When using inline code, it is sometimes possible to generate character strings (i.e., words) that would be listed in a grammatically incorrect way. For example, an inline code might return "apples" "oranges" "bananas", which would ideally be listed as "apples, oranges, and bananas" to be grammatically correct. 

The `combine_words` function in the knitr package does just that. By placing the inline code as a parameter within the `knitr::combinewords()` function, the `combine_words` function will combine the items into a list with commas and an "and" when necessary. Alternatively, `combine_words` will place an "and" between words when there are only two words returned by the inline function, and `combine_words` will not alter the inline functions returned value when it is only a single word. 

To demonstrate, I will use the command `colnames(iris)` to return all of the column header names for the iris dataset, which consists of five different character values. When wrapping the command in the `knitr::combine_words()` function, the inline text becomes `r knitr::combine_words(colnames(iris))` via `` `r
knitr::combine_words(colnames(iris))` ``.

## Turning Numbers Into Words

